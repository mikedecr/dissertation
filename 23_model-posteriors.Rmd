## Model Results {#sec:model-results}

<!-- in chapter: model -->

```{r knitr-02-3_model-results, include = FALSE, cache = FALSE}
source(here::here("assets-bookdown", "knitr-helpers.R"))
```

```{r r-02-3_model-results, cache = FALSE}
library("here")
library("magrittr")
library("tidyverse")
library("boxr"); box_auth()

library("scales")
library("english")
library("latex2exp")
library("patchwork")
# library("ggforce")

# library("rstan")
library("tidybayes")
library("broom")
```

```{r mcmc-data}
# grab most recent filename
most_recent_date <- 
  list.files(here("data", "mcmc", "dgirt", "run", "samples")) %>%
  str_split(pattern = "-mcmc", simplify = TRUE) %>%
  as_tibble(.name_repair = "universal") %>%
  transmute(date = lubridate::ymd(`...1`)) %>%
  filter(date == max(date)) %>%
  pull(date) %>%
  print()

# uniquely identify file (length should be 1)
stopifnot(length(most_recent_date) == 1)

# make filename
mcmc_path <- file.path("data", "mcmc", "dgirt", "run", "samples")
clean_path <- file.path("data", "mcmc", "dgirt", "run", "clean")
input_path <- file.path("data", "mcmc", "dgirt", "run", "input")

most_recent_static <- as.character(most_recent_date) %>%
  str_glue("-mcmc-homsk-2010s.RDS") %>%
  as.character() %>%
  print()

# import MCMC
mcmc <- 
  here(mcmc_path, most_recent_static) %>%
  # here(mcmc_path, "2020-01-10-mcmc-homsk-2010s.RDS") %>% # small?
  readRDS()
```

```{r contextual-data}
# tidy pre-stan data
master_data <- 
  readRDS(here(input_path, "master-model-data.RDS")) %>%
  print()

# stan data
stan_data <- readRDS(here(input_path, "stan-data-list.RDS"))
lapply(stan_data, head)

index_crosswalk <- 
  tibble(
    # factors come from master-data
    group_f = master_data$group,
    item_f = master_data$item,
    state_f = master_data$state,
    region_f = master_data$region,
    district_f = master_data$district,
    party_f = master_data$party,
    # integers from stan (but could be coerced from master?)
    group = stan_data$group, 
    item = stan_data$item,
    state = stan_data$state,
    region = stan_data$region,
    district = stan_data$district,
    party = stan_data$party
  ) %>%
  # the "ordering" of groups as per my mistake in stan prep
  mutate(stan_group_item = row_number()) %>%
  print()
```

```{r mcmc-params}
# model params
load(here(input_path, "mcmc-params.Rdata"))
ls()
```

```{r}
total_samples <- (n_iterations - n_warmup)*(1 / n_thin)*n_chains
```

The model was estimated using a remote server at the University of Wisconsin--Madison.^[
  A Linux server ("Linstat") maintained by Social Science Computing Cooperative.
] 
I generated posterior samples using MCMC on `r smart_number(n_chains)` Markov chains. Each chain was run for `r comma(n_iterations)` iterations, divided into `r comma(n_warmup)` warmup iterations to tune Stan's adaptive HMC algorithm and `r comma(n_iterations - n_warmup)` post-warmup iterations saved for analysis.^[
  The algorithm was initialized with an `adalt_delta` parameter of `r adapt_delta` and a `max_treedepth` of `r max_treedepth`.
]
Following the advice of @Link-Eaton:2011:thinning, I stored every post-warmup sample with no thinning of chains, resulting in a total of `r comma(total_samples)` samples per parameter across all chains.^[
  The chains mix well and exhibit little autocorrelation, which is owed to the fact that Hamiltonian Monte Carlo algorithms are much more efficient at proposing transitions and thus exploring a parameter space.
]

```{r}
theta_tidy <- readRDS(here(clean_path, "theta-tidy.RDS"))
theta_draws <- readRDS(here(clean_path, "theta-draws.RDS"))
```


```{r plot-thetas}
gg_theta_rank <- 
  ggplot(theta_tidy) +
  aes(x = party_rank,  y = estimate, color = as.factor(party)) +
  # geom_linerange(
  #   aes(ymin = conf.low_0.95, ymax = conf.high_0.95),
  #   show.legend = FALSE, size = 0.25, alpha = 0.35
  # ) +
  geom_linerange(
    aes(ymin = conf.low_0.9, ymax = conf.high_0.9),
    show.legend = FALSE, alpha = 0.35
  ) +
  geom_linerange(
    aes(ymin = conf.low_0.5, ymax = conf.high_0.5),
    show.legend = FALSE
  ) +
  geom_point(size = 0.5, color = "black") +
  scale_color_manual(values = party_factor_colors) +
  labs(
    x = "Groups Ordered Within Party", 
    y = "Estimated Policy Preferences",
    title = "Party-Public Ideal Point Estimates",
    subtitle = "Two Parties x 435 Districts"
  ) + 
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  annotate("text", 
    y = c(-0.9, 0.55), x = c(100, 100),
    label = c("Democrats", "Republicans"),
    fontface = "bold"
  ) +
  geom_segment(
    data = theta_tidy %>% filter(party == 1, party_rank == 300),
    aes(y = conf.high_0.5, yend = conf.high_0.5 + 0.25, xend = 250),
    color = "black"
  ) + 
  annotate(
    geom = "text", 
    y = filter(theta_tidy, party == 1, party_rank == 300)$conf.high_0.5 + 0.35, 
    x = 250, 
    label = "50% interval"
  ) +
  geom_segment(
    data = theta_tidy %>% filter(party == 1, party_rank == 350),
    aes(y = conf.high_0.9, yend = conf.high_0.9 + 0.25, xend = 350),
    color = "black"
  ) + 
  annotate(
    geom = "text", 
    y = filter(theta_tidy, party == 1, party_rank == 350)$conf.high_0.5 + 0.5, 
    x = 350, 
    label = "90% interval"
  ) +
  NULL

gg_theta_rank
```

<!-- second: selection of distances -->
<!-- third: histogram of distances -->
<!-- final: heterogeneity -->

```{r plot-combined-posts}
(gg_theta_rank + gg_theta_rank) /
(gg_theta_rank + gg_theta_rank)
```

Here we can reference Figure&nbsp;\@ref(fig:plot-combined-posts).

```{r plot-combined-posts, include = TRUE, fig.width = 8, fig.height = 8, out.width = "100%", fig.cap = "Posteriors"}
```






